<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>OOF Framework Testing Interface</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; max-width: 1100px; margin: 24px auto; }
    textarea { width: 100%; min-height: 140px; margin-bottom: 16px; }
    input[type="file"] { margin-bottom: 12px; }
    button { padding: 10px 16px; font-size: 16px; cursor: pointer; }
    pre { white-space: pre-wrap; background: #f5f5f5; padding: 14px; border-radius: 8px; margin: 0; }
    .box { border: 1px solid #ddd; border-radius: 12px; padding: 14px; margin-bottom: 20px; }
    .muted { color: #666; font-size: 14px; }
    .error { color: #b00020; }
    ul { padding-left: 18px; }
    code { background: #eee; padding: 2px 6px; border-radius: 4px; }
    a { color: inherit; text-decoration: underline; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1 1 340px; }
    label { display:flex; gap:10px; align-items:center; }
    hr { border: none; border-top: 1px solid #ddd; margin: 14px 0; }
  </style>

  <!-- DOCX + XLSX helpers -->
  <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>

<body>
<h1>OOF Framework Testing Interface</h1>
<p class="muted">Runs fully in-browser. Replace API key before use. Do not publish with hardcoded key.</p>

<div class="box">
  <h3>Model</h3>
  <input id="model" type="text" value="gpt-5.2" style="width:100%; padding:10px 12px; border:1px solid #ddd; border-radius:10px;">
  <div class="muted" style="margin-top:6px;">OpenAI Responses API model name</div>
</div>

<div class="box">
  <h3>Framework file (IOOF.txt required)</h3>
  <input id="frameworkFile" type="file" accept=".txt,.md,.json,.csv,.pdf,.docx,.xlsx" />
  <div id="frameworkMeta" class="muted"></div>
  <div class="muted" style="margin-top:8px;">‚ö†Ô∏è IOOF.txt must contain complete schema for validation to work</div>
</div>

<div class="box">
  <h3>User query</h3>
  <textarea id="query" placeholder="Ask something‚Ä¶"></textarea>

  <h3>Web research (optional)</h3>
  <label style="margin: 6px 0 10px;">
    <input id="useWeb" type="checkbox" />
    <span>Use web research (web_search tool)</span>
  </label>

  <div class="muted" style="margin-bottom:8px;">
    Optional: limit web results to specific domains (one per line). Example: <code>reuters.com</code>
  </div>
  <textarea id="allowedDomains" placeholder="Optional allowed domains (one per line)
example.com
wikipedia.org"></textarea>

  <h3>User files (optional)</h3>
  <input id="userFiles" type="file" multiple
    accept=".txt,.md,.json,.csv,.pdf,.docx,.xlsx,.png,.jpg,.jpeg,image/*" />
  <ul id="userFilesList" class="muted"></ul>
</div>

<button id="sendBtn">Send</button>
<span id="status" class="muted" style="margin-left:10px;"></span>

<h3>Response</h3>
<div id="output" class="box">(no response yet)</div>

<script type="module">
/* =====================================================
   üîë HARD-CODE YOUR OPENAI API KEY HERE (PLACEHOLDER)
   ===================================================== */
const API_KEY = "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";

/* =====================================================
   PDF.js (ESM)
   ===================================================== */
import * as pdfjsLib from "https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.min.mjs";
pdfjsLib.GlobalWorkerOptions.workerSrc =
  "https://unpkg.com/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs";

/* =====================================================
   UI + helpers
   ===================================================== */
const statusEl = document.getElementById("status");
const outputEl = document.getElementById("output");

function setStatus(msg, error = false) {
  statusEl.textContent = msg;
  statusEl.className = error ? "error" : "muted";
}

function escapeHtml(s) {
  return (s || "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function listFiles(input, ul) {
  ul.innerHTML = "";
  [...input.files].forEach(f => {
    const li = document.createElement("li");
    li.textContent = `${f.name} (${Math.round(f.size / 1024)} KB)`;
    ul.appendChild(li);
  });
}

document.getElementById("userFiles")
  .addEventListener("change", e =>
    listFiles(e.target, document.getElementById("userFilesList"))
  );

document.getElementById("frameworkFile")
  .addEventListener("change", e => {
    const f = e.target.files[0];
    document.getElementById("frameworkMeta").textContent =
      f ? `${f.name} (${Math.round(f.size / 1024)} KB)` : "";
  });

const isImage = f => (f.type || "").startsWith("image/");
const isPDF   = f => f.type === "application/pdf" || f.name.toLowerCase().endsWith(".pdf");
const isDOCX  = f => f.name.toLowerCase().endsWith(".docx");
const isXLSX  = f => f.name.toLowerCase().endsWith(".xlsx");

function parseAllowedDomains() {
  const raw = (document.getElementById("allowedDomains")?.value || "").trim();
  if (!raw) return [];
  return raw
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean)
    .map(d => d.replace(/^https?:\/\//i, "").replace(/\/.*$/, ""));
}

/* =====================================================
   File parsing (Framework + User files)
   ===================================================== */
async function imageToBase64(file) {
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(r.result.split(",")[1]);
    r.onerror = rej;
    r.readAsDataURL(file);
  });
}

async function pdfToText(file) {
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: buf }).promise;

  let out = "";
  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
    const page = await pdf.getPage(pageNum);
    const tc = await page.getTextContent();
    const pageText = tc.items.map(it => (it.str || "").trim()).filter(Boolean).join(" ");
    out += `\n\n--- PDF Page ${pageNum}/${pdf.numPages} ---\n${pageText}`;
  }
  return out.trim();
}

async function docxToText(file) {
  const buf = await file.arrayBuffer();
  const res = await mammoth.extractRawText({ arrayBuffer: buf });
  return (res.value || "").trim();
}

async function xlsxToText(file) {
  const buf = await file.arrayBuffer();
  const wb = XLSX.read(buf, { type: "array" });

  return wb.SheetNames.map(name => {
    const csv = XLSX.utils.sheet_to_csv(wb.Sheets[name]);
    return `[Sheet: ${name}]\n${csv}`;
  }).join("\n\n");
}

async function processFile(file) {
  if (isImage(file)) {
    return { kind: "image", name: file.name, data: await imageToBase64(file) };
  }
  if (isPDF(file)) {
    return { kind: "text", name: file.name, text: await pdfToText(file) };
  }
  if (isDOCX(file)) {
    return { kind: "text", name: file.name, text: await docxToText(file) };
  }
  if (isXLSX(file)) {
    return { kind: "text", name: file.name, text: await xlsxToText(file) };
  }
  return { kind: "text", name: file.name, text: (await file.text()).trim() };
}

/* =====================================================
   Citation rendering (clickable in-text)
   ===================================================== */
function renderAnnotatedTextAsHtml(text, annotations = []) {
  const cites = (annotations || [])
    .filter(a =>
      a &&
      a.type === "url_citation" &&
      Number.isInteger(a.start_index) &&
      Number.isInteger(a.end_index) &&
      a.start_index >= 0 &&
      a.end_index >= a.start_index
    )
    .sort((a, b) => a.start_index - b.start_index);

  if (!cites.length) {
    return `<pre>${escapeHtml(text || "")}</pre>`;
  }

  let out = "";
  let cursor = 0;

  for (const a of cites) {
    const start = Math.min(a.start_index, text.length);
    const end = Math.min(a.end_index, text.length);

    if (start > cursor) out += escapeHtml(text.slice(cursor, start));

    const citedSpan = text.slice(start, end);
    const url = a.url || "#";
    const title = a.title || url;

    out += `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" title="${escapeHtml(title)}">${escapeHtml(citedSpan)}</a>`;
    cursor = end;
  }

  if (cursor < text.length) out += escapeHtml(text.slice(cursor));
  return `<pre>${out}</pre>`;
}

/* =====================================================
   OOF Physics Validation
   ===================================================== */
function validateCompleteOOFPhysics(physics) {
  const checks = {
    // Metadata
    hasMetadata: physics.metadata ? true : false,
    
    // Level 1 - Fundamental
    has25Operators: Object.keys(physics.level_1_fundamental?.operators || {}).length === 25,
    hasOperatorProduct: physics.level_1_fundamental?.operator_product ? true : false,
    
    // Level 2 - Sacred Chain (7 levels)
    hasSacredChain: (() => {
      const chain = physics.level_2_specification?.sacred_chain;
      if (!chain) return false;
      const required = ['ego', 'memory', 'intellect', 'mind', 'breath', 'body', 'self'];
      return required.every(level => chain[level]);
    })(),
    
    // Level 2 - Complete UCB (8 components)
    hasCompleteUCB: (() => {
      const ucb = physics.level_2_specification?.ucb_complete;
      if (!ucb) return false;
      const required = ['P_presence', 'A_awareness', 'V_vitality', 'E_evolution', 
                       'Psi_clarity', 'M_manifestation', 'L_love_fear_greed', 'G_grace'];
      return required.every(comp => ucb[comp]);
    })(),
    
    // Level 2 - S-Level
    hasSLevel: physics.level_2_specification?.s_level_complete ? true : false,
    
    // Level 2 - Pathways (9)
    hasPathways: (() => {
      const paths = physics.level_2_specification?.nine_pathways;
      if (!paths) return false;
      const required = ['bhakti', 'karma', 'jnana', 'raja', 'tantra', 
                       'kundalini', 'integral', 'shadow', 'grace'];
      return required.every(path => paths[path]);
    })(),
    
    // Level 2 - Circles (5)
    hasCircles: (() => {
      const circles = physics.level_2_specification?.five_circles;
      if (!circles) return false;
      const required = ['circle_1_self', 'circle_2_intimate', 'circle_3_close', 
                       'circle_4_distant', 'circle_5_universal'];
      return required.every(circle => circles[circle]);
    })(),
    
    // Level 2 - Drives (5)
    hasDrives: (() => {
      const drives = physics.level_2_specification?.five_drives;
      if (!drives) return false;
      const required = ['security', 'pleasure', 'power', 'freedom', 'meaning'];
      return required.every(drive => drives[drive]);
    })(),
    
    // Level 2 - Karma
    hasKarma: (() => {
      const karma = physics.level_2_specification?.karma_structure;
      if (!karma) return false;
      return karma.prarabdha_active && karma.sanchita_stored && karma.agami_creating;
    })(),
    
    // Level 2 - Death Architectures
    hasDeath: physics.level_2_specification?.death_architectures ? true : false,
    
    // Level 2 - Transformation Matrices
    hasMatrices: physics.level_2_specification?.transformation_matrices ? true : false,
    
    // Level 2 - Hierarchical Levels
    hasHierarchical: physics.level_2_specification?.hierarchical_levels ? true : false,
    
    // Level 2 - Network Effects
    hasNetwork: physics.level_2_specification?.network_effects ? true : false,
    
    // Level 2 - POMDP Analysis
    hasPOMDP: physics.level_2_specification?.pomdp_analysis ? true : false,
    
    // Level 2 - Temporal Dynamics
    hasTemporal: physics.level_2_specification?.temporal_dynamics ? true : false,
    
    // Level 2 - Space Field
    hasSpace: physics.level_2_specification?.space_field ? true : false,
    
    // Level 2 - Operator Interactions
    hasInteractions: (() => {
      const interact = physics.level_2_specification?.operator_interactions;
      if (!interact) return false;
      return interact.inverse_pairs && interact.power_trinities;
    })(),
    
    // Level 2 - Guna Configuration
    hasGuna: (() => {
      const guna = physics.level_2_specification?.guna_configuration;
      if (!guna) return false;
      return guna.sattva && guna.rajas && guna.tamas;
    })(),
    
    // Level 2 - Kosha Layers
    hasKosha: (() => {
      const kosha = physics.level_2_specification?.kosha_layers;
      if (!kosha) return false;
      const required = ['annamaya', 'pranamaya', 'manomaya', 'vijnanamaya', 'anandamaya'];
      return required.every(layer => kosha[layer]);
    })(),
    
    // Level 2 - Shakti Trinity
    hasShakti: (() => {
      const shakti = physics.level_2_specification?.shakti_trinity;
      if (!shakti) return false;
      return shakti.iccha_will && shakti.kriya_action && shakti.jnana_knowledge;
    })(),
    
    // Formulas (minimum 15)
    hasFormulas: (physics.formulas_comprehensive || []).length >= 15,
    
    // Predictions (minimum 5)
    hasPredictions: (physics.predictions || []).length >= 5,
    
    // Transformation Vector
    hasTransformation: physics.transformation_vector ? true : false,
    
    // Coherence Analysis
    hasCoherence: (() => {
      const coh = physics.coherence_analysis;
      if (!coh) return false;
      return coh.fundamental_level && coh.specification_level && 
             coh.overall_coherence;
    })(),
    
    // Execution Metadata
    hasExecutionMetadata: physics.execution_metadata ? true : false
  };
  
  const passed = Object.entries(checks).filter(([k, v]) => v === true);
  const failed = Object.entries(checks).filter(([k, v]) => v === false);
  
  const allPassed = failed.length === 0;
  const completeness = (passed.length / Object.keys(checks).length) * 100;
  
  return {
    valid: allPassed,
    completeness: completeness,
    passed: passed.length,
    total: Object.keys(checks).length,
    failed: failed.map(([k]) => k),
    message: allPassed 
      ? `Complete OOF physics validated (${passed.length}/${Object.keys(checks).length} components)`
      : `Physics incomplete (${passed.length}/${Object.keys(checks).length} components). Missing: ${failed.map(([k]) => k).join(', ')}`
  };
}

/* =====================================================
   SEND
   ===================================================== */
document.getElementById("sendBtn").onclick = async () => {
  try {
    const MODEL = (document.getElementById("model").value || "gpt-5.2").trim();

    if (!API_KEY || API_KEY.includes("PASTE_YOUR_OPENAI_API_KEY_HERE")) {
      throw new Error("API key not set. Replace PASTE_YOUR_OPENAI_API_KEY_HERE in the HTML.");
    }
    if (!MODEL) throw new Error("Model missing.");
    const query = document.getElementById("query").value.trim();
    if (!query) throw new Error("Missing user query.");

    setStatus("Processing files‚Ä¶");
    outputEl.innerHTML = "";

    // Framework -> instructions (load as-is, no additions)
    let instructions = "No framework provided.";
    const fwFile = document.getElementById("frameworkFile").files[0];
    if (fwFile) {
      const fw = await processFile(fwFile);

      if (fw.kind !== "text") {
        throw new Error("Framework file must be text-based (PDF/DOCX/XLSX/TXT/etc.).");
      }

      // Send framework text as-is (IOOF.txt should contain complete schema)
      instructions = fw.text;
    }

    // Build user message content
    const content = [{ type: "input_text", text: `User query:\n${query}` }];

    const userFiles = document.getElementById("userFiles").files;
    for (const f of userFiles) {
      const p = await processFile(f);
      if (p.kind === "text") {
        content.push({
          type: "input_text",
          text: `\n[User file: ${p.name}]\n${p.text}`
        });
      } else {
        content.push({ type: "input_image", image_base64: p.data });
        content.push({ type: "input_text", text: `[Image: ${p.name}]` });
      }
    }

    // Web research tool config
    const useWeb = document.getElementById("useWeb").checked;
    const allowedDomains = parseAllowedDomains();

    const tools = [];
    if (useWeb) {
      const webTool = { type: "web_search" };

      if (allowedDomains.length) {
        webTool.filters = { allowed_domains: allowedDomains };
      }

      webTool.user_location = { type: "approximate", timezone: "Asia/Dubai" };
      tools.push(webTool);
    }

    setStatus(useWeb ? "Calling model (with web research)‚Ä¶" : "Calling model‚Ä¶");

    const reqBody = {
      model: MODEL,
      instructions,
      input: [{
        type: "message",
        role: "user",
        content
      }],
      ...(tools.length ? { tools, tool_choice: "auto" } : {}),
      ...(useWeb ? { include: ["web_search_call.action.sources"] } : {})
    };

    const res = await fetch("https://api.openai.com/v1/responses", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + API_KEY,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(reqBody)
    });

    const data = await res.json();
    if (!res.ok) {
      throw new Error(typeof data === "object" ? JSON.stringify(data, null, 2) : String(data));
    }

    // Find assistant message + output_text part
    const msg = (data.output || []).find(o => o.type === "message" && o.role === "assistant");
    const part = msg?.content?.find(c => c.type === "output_text");

    const text = part?.text || data.output_text || "";
    const annotations = part?.annotations || [];

    // ========================================
    // VALIDATE OOF PHYSICS
    // ========================================
    setStatus("Validating physics calculations...");
    
    try {
      const physicsMatch = text.match(/<!-- OOF_PHYSICS\s*(\{[\s\S]*?\})\s*-->/);
      
      if (!physicsMatch) {
        throw new Error('CRITICAL: Response missing OOF_PHYSICS block. Framework not applied.');
      }

      const physics = JSON.parse(physicsMatch[1]);
      const validation = validateCompleteOOFPhysics(physics);
      
      if (!validation.valid) {
        console.error('Physics validation failed:', validation.message);
        setStatus('Physics validation failed', true);
        outputEl.innerHTML = `
          <pre style="color: #b00020; padding: 20px; background: #fff3e0; border-left: 4px solid #b00020;">
<strong>‚ö†Ô∏è  PHYSICS VALIDATION FAILED</strong>

The LLM calculated only ${validation.completeness.toFixed(1)}% of the required framework.

<strong>Missing components (${validation.failed.length}):</strong>
${validation.failed.map(f => '  ‚Ä¢ ' + f).join('\n')}

<strong>Why this matters:</strong>
The framework's power comes from COMPLETE calculation of all 500+ components.
Partial analysis produces vanilla-quality output.

The response has been rejected. Please try again.
          </pre>
        `;
        return;
      }
      
      console.log('‚úì Physics validation passed:', validation.message);
      console.log('‚úì Completeness:', validation.completeness.toFixed(1) + '%');
      
    } catch (validationError) {
      console.error('Validation error:', validationError);
      setStatus('Physics validation error', true);
      outputEl.innerHTML = `<pre style="color: #b00020;">${escapeHtml(validationError.message)}</pre>`;
      return;
    }
    // ========================================
    // END VALIDATION
    // ========================================

    setStatus("Physics validated - rendering response...");

    outputEl.innerHTML = text
      ? renderAnnotatedTextAsHtml(text, annotations)
      : "<pre>(empty)</pre>";

    // Append sources list if web was used
    if (useWeb) {
      const webCalls = (data.output || []).filter(o => o.type === "web_search_call");
      const sources = webCalls.flatMap(c => c?.action?.sources || []).filter(Boolean);

      if (sources.length) {
        const sourcesHtml = sources.slice(0, 50).map(s => {
          const url = s.url || "";
          const title = s.title || url;
          const domain = s.source || "";
          return `<li><a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(title)}</a> <span class="muted">(${escapeHtml(domain)})</span></li>`;
        }).join("");

        outputEl.innerHTML += `
          <hr>
          <div class="muted" style="margin-bottom:6px;"><b>Sources (from web search)</b></div>
          <ul style="margin:0; padding-left:18px;">${sourcesHtml}</ul>
        `;
      }
    }

    setStatus("Done.");
  } catch (e) {
    setStatus("Error.", true);
    outputEl.innerHTML = `<pre>${escapeHtml(e?.message || String(e))}</pre>`;
  }
};
</script>

</body>
</html>
