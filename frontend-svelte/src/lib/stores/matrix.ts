/**
 * Matrix store - manages multi-document transformation matrix state
 *
 * ARCHITECTURE:
 * - Each document has its own 10x10 matrix (rows, columns, cells)
 * - Documents are displayed as tabs in Control Popup and Matrix Panel
 * - User can select 5 rows + 5 columns per document for display
 * - Row/column labels and insight titles are generated by LLM during document creation
 * - Articulated insights are generated on-demand when user clicks an insight title
 * - Document population (cells, plays, etc.) triggered via "Design Your Reality" button
 */

import { writable, derived, get } from 'svelte/store';
import { api } from '$utils/api';
import { addToast } from './toast';

export interface CellDimension {
	name: string;
	value: number;  // 0 (Low), 50 (Medium), or 100 (High)
	explanation?: string;  // Max 10-word phrase explaining this dimension's state
}

export interface CellData {
	value: number;
	dimensions: CellDimension[];
	confidence: number;
	description: string;
	isLeveragePoint: boolean;
	isRiskPoint: boolean;
	riskLevel?: 'low' | 'medium' | 'high';
}

// Articulated Insight structure based on insight-articulation-final.pdf
// 3-component structure: THE TRUTH → YOUR TRUTH → THE MARK (160-250 words total)
export interface ArticulatedInsight {
	// Insight title (max 10 words) - displayed in popup header
	title: string;               // Max 10-word title phrase for this insight

	// MICRO MOMENT (40-60 words): Fly-on-wall scene in user's world
	micro_moment: string;        // Present tense, sensory, user's actual context

	// THE TRUTH (80-120 words): Analogy from outside user's domain
	the_truth: string;           // Italicized analogy, present tense, sensory
	the_truth_law: string;       // Bold one-line universal law (15-25 words)

	// YOUR TRUTH (50-80 words): Recognition + future protection
	your_truth: string;          // "I see you" + "never miss again" trigger
	your_truth_revelation: string;  // Bold revelation - what's now visible

	// THE MARK (30-50 words): Install the insight as permanent pattern
	the_mark_name: string;       // Memorable name, 2-5 words (e.g., "The Permission Gap")
	the_mark_prediction: string; // Where they'll see this pattern
	the_mark_identity: string;   // Bold new capability/identity
}

// Play (transformation strategy)
export interface Play {
	id: string;
	name: string;
	description: string;
	fitScore: number;
	risk: 'low' | 'medium' | 'high';
	timeline: string;
	phases: number;
	steps: string[];
	leveragePointIds: string[];
	expectedImprovement: number;
	category: string;  // "quick_wins", "balanced", "deep_transform", "conservative", "aggressive"
}

export interface RowOption {
	id: string;
	label: string;
	insight_title?: string;
	articulated_insight?: ArticulatedInsight;
}

export interface ColumnOption {
	id: string;
	label: string;
	insight_title?: string;
	articulated_insight?: ArticulatedInsight;
}

// Backend leverage point / risk analysis structures (generated by LLM during design-reality)
export interface LeveragePoint {
	cell_id: string;          // e.g., "R0C2" — refers to 10x10 matrix indices
	cell_label: string;
	description: string;
	why_leverage: string;
	cascade_effects: string[];
	recommended_actions: string[];
	impact_score: number;
	effort_score: number;
	roi_ratio: number;
}

export interface RiskPoint {
	cell_id: string;          // e.g., "R1C3" — refers to 10x10 matrix indices
	cell_label: string;
	risk_level: 'low' | 'medium' | 'high';
	description: string;
	risk_factors: string[];
	mitigation_strategies: string[];
	dependencies: string[];
	impact_if_ignored: string;
}

// New: Document with its own matrix data
export interface DocumentPreview {
	tempId: string;
	name: string;
	rowLabels: string[];
	columnLabels: string[];
	insightTitles: string[];
}

export interface Document {
	id: string;
	name: string;
	description?: string;  // ~20 word description (optional in on-demand architecture)
	leverage_points?: LeveragePoint[];   // 3-5 cells identified by LLM as strategic power spots
	risk_analysis?: RiskPoint[];         // 3-6 cells identified by LLM as risks/bottlenecks
	matrix_data: {
		row_options: RowOption[];
		column_options: ColumnOption[];
		selected_rows: number[];
		selected_columns: number[];
		viewed_insight_indices?: number[];  // Indices the user has explicitly opened (0-9 rows, 10-19 columns)
		cells?: Record<string, {
			impact_score: number;
			relationship?: string;
			dimensions: {
				name: string;
				value: number;  // 0 (Low), 50 (Medium), or 100 (High)
				explanation?: string;  // Max 10-word phrase explaining this dimension's state
			}[];
		}>;
	};
}

interface MatrixState {
	// All documents (each with its own matrix)
	documents: Document[];
	activeDocumentId: string | null;

	// Displayed 5x5 matrix (derived from active document's selections)
	displayedMatrixData: CellData[][];
	displayedRowHeaders: string[];
	displayedColumnHeaders: string[];
	displayedRowInsights: string[];
	displayedColumnInsights: string[];

	// Generation state
	isGenerated: boolean;

	// Risk heatmap state
	showRiskHeatmap: boolean;

	// Processing state (long-running LLM operations)
	isProcessing: boolean;

	// Plays state
	plays: Play[];
	selectedPlayId: string | null;
	isLoadingPlays: boolean;

	error: string | null;

	// Conversation ID for API calls
	conversationId: string | null;

	// Auto refresh - when enabled, matrix auto-updates on next query
	autoRefresh: boolean;
}

// Create placeholder 5x5 matrix for initial render
function createPlaceholderMatrix(): CellData[][] {
	const placeholderDimensions: CellDimension[] = Array.from({ length: 5 }, (_, i) => ({
		name: `Dimension ${i + 1}`,
		value: 50
	}));

	const placeholderCell: CellData = {
		value: 50,
		dimensions: placeholderDimensions,
		confidence: 0.5,
		description: '',
		isLeveragePoint: false,
		isRiskPoint: false,
		riskLevel: 'low'
	};

	return Array.from({ length: 5 }, () =>
		Array.from({ length: 5 }, () => ({ ...placeholderCell, dimensions: placeholderDimensions.map(d => ({ ...d })) }))
	);
}

const initialState: MatrixState = {
	documents: [],
	activeDocumentId: null,

	displayedMatrixData: createPlaceholderMatrix(),
	displayedRowHeaders: ['Row 1', 'Row 2', 'Row 3', 'Row 4', 'Row 5'],
	displayedColumnHeaders: ['Column 1', 'Column 2', 'Column 3', 'Column 4', 'Column 5'],
	displayedRowInsights: ['', '', '', '', ''],
	displayedColumnInsights: ['', '', '', '', ''],

	isGenerated: false,

	isProcessing: false,

	showRiskHeatmap: false,

	plays: [],
	selectedPlayId: null,
	isLoadingPlays: false,

	error: null,
	conversationId: null,
	autoRefresh: false
};

function createMatrixStore() {
	const { subscribe, set, update } = writable<MatrixState>(initialState);

	// AbortControllers for cancellable LLM operations
	let populateController: AbortController | null = null;
	let previewController: AbortController | null = null;
	let addDocsController: AbortController | null = null;
	let insightController: AbortController | null = null;

	// Helper to build displayed 5x5 from a document's selected rows/columns
	function buildDisplayedMatrix(doc: Document): {
		matrixData: CellData[][];
		rowHeaders: string[];
		columnHeaders: string[];
		rowInsights: string[];
		columnInsights: string[];
	} | null {
		if (!doc.matrix_data) return null;

		const placeholderDimensions: CellDimension[] = Array.from({ length: 5 }, (_, i) => ({
			name: `Dimension ${i + 1}`,
			value: 50  // Medium
		}));

		// Nullish coalescing required: Pydantic serializes Optional fields as JSON null,
		// but JS destructuring defaults only apply for undefined, not null
		const row_options = doc.matrix_data.row_options ?? [];
		const column_options = doc.matrix_data.column_options ?? [];
		const selected_rows = doc.matrix_data.selected_rows ?? [0, 1, 2, 3, 4];
		const selected_columns = doc.matrix_data.selected_columns ?? [0, 1, 2, 3, 4];
		const cells = doc.matrix_data.cells ?? {};

		const rowHeaders = selected_rows.map(i => row_options[i]?.label || `Row ${i + 1}`);
		const columnHeaders = selected_columns.map(i => column_options[i]?.label || `Column ${i + 1}`);
		const rowInsights = selected_rows.map(i => row_options[i]?.insight_title || row_options[i]?.articulated_insight?.title || '');
		const columnInsights = selected_columns.map(i => column_options[i]?.insight_title || column_options[i]?.articulated_insight?.title || '');

		// Build lookup sets from the backend's LLM-generated leverage_points and risk_analysis arrays.
		// These use cell_id format "R{row}C{col}" referring to the 10x10 matrix indices.
		const leveragePointIds = new Set(doc.leverage_points?.map(lp => lp.cell_id) ?? []);
		const riskPointMap = new Map<string, 'low' | 'medium' | 'high'>(
			(doc.risk_analysis ?? []).map(rp => [rp.cell_id, rp.risk_level as 'low' | 'medium' | 'high'])
		);

		const matrixData: CellData[][] = selected_rows.map(rowIdx =>
			selected_columns.map(colIdx => {
				const cellKey = `${rowIdx}-${colIdx}`;
				const cellId = `R${rowIdx}C${colIdx}`;
				const cell = cells[cellKey];

				const isLeveragePoint = leveragePointIds.has(cellId);
				const riskEntry = riskPointMap.get(cellId);
				const isRiskPoint = !!riskEntry;

				if (!cell) {
					return {
						value: 50,
						dimensions: placeholderDimensions.map(d => ({ ...d })),
						confidence: 0.5,
						description: '',
						isLeveragePoint,
						isRiskPoint,
						riskLevel: riskEntry ?? ('low' as const)
					};
				}

				const dimensions: CellDimension[] = cell.dimensions?.map(d => ({
					name: d.name,
					value: d.value,
					explanation: d.explanation
				})) || placeholderDimensions;
				const finalDims = dimensions.length === 5 ? dimensions : placeholderDimensions;
				const dimAvg = finalDims.reduce((sum, d) => sum + d.value, 0) / finalDims.length;

				return {
					value: Math.round(dimAvg),
					dimensions: finalDims,
					confidence: dimAvg / 100,
					description: cell.relationship || '',
					isLeveragePoint,
					isRiskPoint,
					riskLevel: riskEntry ?? ('low' as const)
				};
			})
		);

		return { matrixData, rowHeaders, columnHeaders, rowInsights, columnInsights };
	}

	// Patch a single document into the store and rebuild display if it's the active doc
	function applyDocumentUpdate(doc: Document) {
		update(state => {
			const docIndex = state.documents.findIndex(d => d.id === doc.id);
			if (docIndex === -1) return state;

			const updatedDocs = [...state.documents];
			updatedDocs[docIndex] = doc;

			if (state.activeDocumentId === doc.id) {
				const displayed = buildDisplayedMatrix(doc);
				if (!displayed) return { ...state, documents: updatedDocs };
				return {
					...state,
					documents: updatedDocs,
					displayedMatrixData: displayed.matrixData,
					displayedRowHeaders: displayed.rowHeaders,
					displayedColumnHeaders: displayed.columnHeaders,
					displayedRowInsights: displayed.rowInsights,
					displayedColumnInsights: displayed.columnInsights,
					isGenerated: !!doc.matrix_data?.cells && Object.keys(doc.matrix_data.cells).length > 0
				};
			}

			return { ...state, documents: updatedDocs };
		});
	}

	return {
		subscribe,

		// Set conversation ID for API calls
		setConversationId(conversationId: string) {
			update(state => ({ ...state, conversationId }));
		},

		// Populate from structured data received from backend (documents array format)
		populateFromStructuredData(data: { documents?: Document[] }) {
			if (!data || !data.documents || data.documents.length === 0) return;

			const incomingDocs = data.documents;

			// Merge incoming docs with existing: update matching IDs, preserve the rest
			update(state => {
				const existingDocs = state.documents;
				let mergedDocs: Document[];

				if (existingDocs.length === 0) {
					// No existing docs — use incoming as-is
					mergedDocs = incomingDocs;
				} else {
					// Start with existing docs, update any that match incoming by ID
					mergedDocs = existingDocs.map(existing => {
						const incoming = incomingDocs.find(d => d.id === existing.id);
						if (incoming) {
							// Merge: incoming labels/titles, preserve existing cells/insights/leverage
							return {
								...existing,
								name: incoming.name || existing.name,
								description: incoming.description || existing.description,
								leverage_points: incoming.leverage_points ?? existing.leverage_points,
								risk_analysis: incoming.risk_analysis ?? existing.risk_analysis,
								matrix_data: {
									...existing.matrix_data,
									row_options: incoming.matrix_data?.row_options ?? existing.matrix_data?.row_options,
									column_options: incoming.matrix_data?.column_options ?? existing.matrix_data?.column_options,
									selected_rows: incoming.matrix_data?.selected_rows ?? existing.matrix_data?.selected_rows,
									selected_columns: incoming.matrix_data?.selected_columns ?? existing.matrix_data?.selected_columns,
								}
							};
						}
						return existing;
					});
					// Add any incoming docs that don't exist yet
					for (const inc of incomingDocs) {
						if (!mergedDocs.find(d => d.id === inc.id)) {
							mergedDocs.push(inc);
						}
					}
				}

				// Preserve current active document if it still exists; otherwise pick first with matrix_data
				const currentActive = state.activeDocumentId
					? mergedDocs.find(d => d.id === state.activeDocumentId)
					: null;
				const activeDoc = currentActive || mergedDocs.find(d => d.matrix_data) || mergedDocs[0];
				const activeDocumentId = activeDoc.id;
				const displayed = buildDisplayedMatrix(activeDoc);

				if (!displayed) {
					return {
						...state,
						documents: mergedDocs,
						activeDocumentId,
						isGenerated: false
					};
				}

				return {
					...state,
					documents: mergedDocs,
					activeDocumentId,
					displayedMatrixData: displayed.matrixData,
					displayedRowHeaders: displayed.rowHeaders,
					displayedColumnHeaders: displayed.columnHeaders,
					displayedRowInsights: displayed.rowInsights,
					displayedColumnInsights: displayed.columnInsights,
					isGenerated: !!activeDoc.matrix_data?.cells && Object.keys(activeDoc.matrix_data.cells).length > 0
				};
			});
		},

		// Switch active document tab
		setActiveDocument(documentId: string) {
			update(state => {
				const doc = state.documents.find(d => d.id === documentId);
				if (!doc) return state;

				const displayed = buildDisplayedMatrix(doc);
				if (!displayed) return { ...state, activeDocumentId: documentId, isGenerated: false };

				return {
					...state,
					activeDocumentId: documentId,
					displayedMatrixData: displayed.matrixData,
					displayedRowHeaders: displayed.rowHeaders,
					displayedColumnHeaders: displayed.columnHeaders,
					displayedRowInsights: displayed.rowInsights,
					displayedColumnInsights: displayed.columnInsights,
					isGenerated: !!doc.matrix_data?.cells && Object.keys(doc.matrix_data.cells).length > 0
				};
			});
		},

		// Update row/column selection for active document
		async updateDocumentSelection(selectedRows: number[], selectedColumns: number[]) {
			const state = get({ subscribe });
			const activeDoc = state.documents.find(d => d.id === state.activeDocumentId);
			if (!activeDoc?.matrix_data || !state.conversationId) return;

			// Save original selection for rollback
			const originalRows = [...(activeDoc.matrix_data.selected_rows ?? [0, 1, 2, 3, 4])];
			const originalCols = [...(activeDoc.matrix_data.selected_columns ?? [0, 1, 2, 3, 4])];

			// Optimistic update
			update(s => {
				const docIndex = s.documents.findIndex(d => d.id === s.activeDocumentId);
				if (docIndex === -1) return s;

				const updatedDocs = [...s.documents];
				updatedDocs[docIndex] = {
					...updatedDocs[docIndex],
					matrix_data: {
						...updatedDocs[docIndex].matrix_data,
						selected_rows: selectedRows,
						selected_columns: selectedColumns
					}
				};

				const displayed = buildDisplayedMatrix(updatedDocs[docIndex]);
				if (!displayed) return { ...s, documents: updatedDocs };

				return {
					...s,
					documents: updatedDocs,
					displayedMatrixData: displayed.matrixData,
					displayedRowHeaders: displayed.rowHeaders,
					displayedColumnHeaders: displayed.columnHeaders,
					displayedRowInsights: displayed.rowInsights,
					displayedColumnInsights: displayed.columnInsights
				};
			});

			// Persist to backend
			try {
				await api.patch(`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/selection`, {
					document_id: state.activeDocumentId,
					selected_rows: selectedRows,
					selected_columns: selectedColumns
				});
			} catch (error) {
				console.error('Failed to persist document selection:', error);

				// Rollback to original selection
				update(s => {
					const docIndex = s.documents.findIndex(d => d.id === s.activeDocumentId);
					if (docIndex === -1) return s;

					const updatedDocs = [...s.documents];
					updatedDocs[docIndex] = {
						...updatedDocs[docIndex],
						matrix_data: {
							...updatedDocs[docIndex].matrix_data,
							selected_rows: originalRows,
							selected_columns: originalCols
						}
					};

					const displayed = buildDisplayedMatrix(updatedDocs[docIndex]);
					if (!displayed) return { ...s, documents: updatedDocs };

					return {
						...s,
						documents: updatedDocs,
						displayedMatrixData: displayed.matrixData,
						displayedRowHeaders: displayed.rowHeaders,
						displayedColumnHeaders: displayed.columnHeaders,
						displayedRowInsights: displayed.rowInsights,
						displayedColumnInsights: displayed.columnInsights
					};
				});

				addToast('error', 'Failed to update selection. Reverted.');
			}
		},

		// Delete a document (only from CC popup, never from Matrix panel)
		async deleteDocument(docId: string) {
			const state = get({ subscribe });
			if (!state.conversationId) {
				console.error('No conversation ID set');
				return;
			}

			if (state.documents.length <= 1) {
				addToast('error', 'Cannot delete the last document');
				return;
			}

			try {
				await api.delete(`/api/matrix/${state.conversationId}/document/${docId}`);

				update(s => {
					const remaining = s.documents.filter(d => d.id !== docId);
					// If deleted doc was active, switch to first remaining
					const needSwitch = s.activeDocumentId === docId;
					const newActiveId = needSwitch ? remaining[0]?.id ?? null : s.activeDocumentId;
					const newActiveDoc = remaining.find(d => d.id === newActiveId);

					if (needSwitch && newActiveDoc) {
						const displayed = buildDisplayedMatrix(newActiveDoc);
						if (displayed) {
							return {
								...s,
								documents: remaining,
								activeDocumentId: newActiveId,
								displayedMatrixData: displayed.matrixData,
								displayedRowHeaders: displayed.rowHeaders,
								displayedColumnHeaders: displayed.columnHeaders,
								displayedRowInsights: displayed.rowInsights,
								displayedColumnInsights: displayed.columnInsights,
								isGenerated: !!newActiveDoc.matrix_data?.cells && Object.keys(newActiveDoc.matrix_data.cells).length > 0
							};
						}
						return { ...s, documents: remaining, activeDocumentId: newActiveId, isGenerated: false };
					}

					return { ...s, documents: remaining };
				});

				addToast('info', 'Document deleted');
			} catch (error: any) {
				console.error('Failed to delete document:', error);
				addToast('error', 'Failed to delete document');
			}
		},

		// Generate 3 document previews for user selection
		async previewDocuments(model: string = 'claude-opus-4-5-20251101'): Promise<DocumentPreview[]> {
			const state = get({ subscribe });
			if (!state.conversationId) return [];

			previewController = new AbortController();
			update(s => ({ ...s, isProcessing: true }));
			try {
				const response = await api.post<{ previews: DocumentPreview[] }>(
					`/api/matrix/${state.conversationId}/documents/preview`,
					{ model },
					{ timeout: 300000, retries: 1, signal: previewController.signal }
				);
				return response.previews ?? [];
			} catch (error: any) {
				if (error.name === 'AbortError') return [];
				console.error('Failed to generate document previews:', error);
				addToast('error', 'Failed to generate document previews');
				return [];
			} finally {
				previewController = null;
				update(s => ({ ...s, isProcessing: false }));
			}
		},

		cancelPreview() {
			previewController?.abort();
		},

		// Add selected previews as new documents, then reload full document list
		async addDocuments(selectedPreviewIds: string[], model: string = 'claude-opus-4-5-20251101') {
			const state = get({ subscribe });
			if (!state.conversationId) return;

			const previousDocIds = new Set(state.documents.map(d => d.id));

			addDocsController = new AbortController();
			update(s => ({ ...s, isProcessing: true }));
			try {
				await api.post(
					`/api/matrix/${state.conversationId}/documents/add`,
					{ selected_preview_ids: selectedPreviewIds, model },
					{ timeout: 300000, retries: 1, signal: addDocsController.signal }
				);

				// Reload full document list from backend
				const documents = await api.get<Document[]>(
					`/api/matrix/${state.conversationId}/documents`
				);

				if (documents?.length) {
					// Switch to the first newly added document so it's immediately visible
					const firstNewDoc = documents.find(d => !previousDocIds.has(d.id));
					const activeDoc = firstNewDoc || documents.find(d => d.id === state.activeDocumentId) || documents[0];
					const displayed = buildDisplayedMatrix(activeDoc);

					update(s => ({
						...s,
						documents,
						activeDocumentId: activeDoc.id,
						...(displayed ? {
							displayedMatrixData: displayed.matrixData,
							displayedRowHeaders: displayed.rowHeaders,
							displayedColumnHeaders: displayed.columnHeaders,
							displayedRowInsights: displayed.rowInsights,
							displayedColumnInsights: displayed.columnInsights,
						} : {}),
						isGenerated: !!activeDoc.matrix_data?.cells && Object.keys(activeDoc.matrix_data.cells).length > 0
					}));
				}

				addToast('info', 'Documents added');
			} catch (error: any) {
				if (error.name === 'AbortError') return;
				console.error('Failed to add documents:', error);
				addToast('error', 'Failed to add documents');
			} finally {
				addDocsController = null;
				update(s => ({ ...s, isProcessing: false }));
			}
		},

		cancelAddDocuments() {
			addDocsController?.abort();
		},

		// Populate a document with full cell data via "Design Your Reality"
		async populateDocument(docId: string, model: string = 'claude-opus-4-5-20251101') {
			const state = get({ subscribe });
			if (!state.conversationId) {
				console.error('No conversation ID set');
				return;
			}

			populateController = new AbortController();
			update(s => ({ ...s, isProcessing: true }));
			try {
				// Backend returns the updated document directly — no follow-up GET needed
				const doc = await api.post<Document>(
					`/api/matrix/${state.conversationId}/document/${docId}/design-reality`,
					{ model },
					{ timeout: 300000, retries: 1, signal: populateController.signal }
				);

				if (doc?.matrix_data) {
					applyDocumentUpdate(doc);
				}

				return doc;
			} catch (error: any) {
				if (error.name === 'AbortError') return;
				console.error('Failed to populate document:', error);
				throw error;
			} finally {
				populateController = null;
				update(s => ({ ...s, isProcessing: false }));
			}
		},

		cancelPopulate() {
			populateController?.abort();
		},

		// Generate all missing insights for the active document
		async generateInsights(insightIndex: number, model: string): Promise<Document | null> {
			const state = get({ subscribe });
			if (!state.conversationId) throw new Error('No conversation selected');
			if (!state.activeDocumentId) throw new Error('No document selected');

			insightController = new AbortController();
			update(s => ({ ...s, isProcessing: true }));
			try {
				// Backend returns the updated document directly — no follow-up GET needed
				// LLM insight generation can take up to 5 minutes — override default 30s timeout
				const doc = await api.post<Document>(
					`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/generate-insights`,
					{ model, insight_index: insightIndex },
					{ timeout: 300000, retries: 1, signal: insightController.signal }
				);

				if (doc?.matrix_data) {
					applyDocumentUpdate(doc);
					return doc;
				}
				return null;
			} catch (error: any) {
				if (error.name === 'AbortError') return null;
				throw error;
			} finally {
				insightController = null;
				update(s => ({ ...s, isProcessing: false }));
			}
		},

		cancelInsight() {
			insightController?.abort();
		},

		// Fetch plays for active document (plays are generated during document population)
		async fetchPlays() {
			const state = get({ subscribe });
			if (!state.conversationId || !state.activeDocumentId) {
				console.error('No conversation or document ID set');
				return [];
			}

			update(s => ({ ...s, isLoadingPlays: true, error: null }));

			try {
				const response = await api.get<{ plays: Play[]; selectedPlayId: string | null }>(
					`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/plays`
				);
				const plays = response.plays || [];
				const selectedPlayId = response.selectedPlayId || null;

				update(s => ({
					...s,
					plays,
					selectedPlayId,
					isLoadingPlays: false
				}));

				return plays;
			} catch (error: any) {
				update(s => ({
					...s,
					plays: [],
					isLoadingPlays: false,
					error: error.message || 'Failed to fetch plays'
				}));
				return [];
			}
		},

		// Select a play
		async selectPlay(playId: string | null) {
			const state = get({ subscribe });
			if (!state.conversationId || !state.activeDocumentId) {
				console.error('No conversation or document ID set');
				return;
			}

			const previousPlayId = state.selectedPlayId;
			// Optimistic update
			update(s => ({ ...s, selectedPlayId: playId }));

			try {
				await api.put(
					`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/plays/select`,
					{ play_id: playId }
				);
			} catch (error: any) {
				console.error('Failed to select play:', error);
				// Rollback on failure
				update(s => ({ ...s, selectedPlayId: previousPlayId }));
				addToast('error', 'Failed to select play');
			}
		},

		// Update cell dimension value and recompute derived fields (local state only).
		// isLeveragePoint and isRiskPoint are preserved from backend LLM analysis — NOT recalculated.
		updateCellDimension(rowIdx: number, colIdx: number, dimIdx: number, value: number) {
			update(state => {
				const newMatrixData = state.displayedMatrixData.map((row, r) =>
					row.map((cell, c) => {
						if (r === rowIdx && c === colIdx) {
							const newDimensions = cell.dimensions.map((dim, d) =>
								d === dimIdx ? { ...dim, value } : dim
							);
							const dimAvg = newDimensions.reduce((sum, d) => sum + d.value, 0) / newDimensions.length;
							return { ...cell, dimensions: newDimensions, value: Math.round(dimAvg) };
						}
						return cell;
					})
				);
				return { ...state, displayedMatrixData: newMatrixData };
			});
		},

		// Save cell dimension changes to backend
		async saveCellChanges(changes: Array<{ row: number; col: number; dimIdx: number; value: number }>) {
			const state = get({ subscribe });
			if (!state.conversationId || !state.activeDocumentId) {
				console.error('No conversation or document ID set');
				return { success: false, changesSaved: 0 };
			}

			if (changes.length === 0) {
				return { success: true, changesSaved: 0 };
			}

			// Save original state for rollback
			const originalMatrixData = state.displayedMatrixData.map(row =>
				row.map(cell => ({
					...cell,
					dimensions: cell.dimensions.map(dim => ({ ...dim }))
				}))
			);

			try {
				// Apply changes to local state first (optimistic update)
				update(s => {
					const newMatrixData = s.displayedMatrixData.map((row, r) =>
						row.map((cell, c) => {
							const cellChanges = changes.filter(ch => ch.row === r && ch.col === c);
							if (cellChanges.length === 0) return cell;

							const newDimensions = cell.dimensions.map((dim, d) => {
								const dimChange = cellChanges.find(ch => ch.dimIdx === d);
								return dimChange ? { ...dim, value: dimChange.value } : dim;
							});
							return { ...cell, dimensions: newDimensions };
						})
					);
					return { ...s, displayedMatrixData: newMatrixData };
				});

				// Persist to backend
				const response = await api.patch<{ success: boolean; changes_saved: number }>(
					`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/cells`,
					{
						changes: changes.map(ch => ({
							row_idx: ch.row,
							col_idx: ch.col,
							dim_idx: ch.dimIdx,
							value: ch.value
						}))
					}
				);

				return {
					success: response.success,
					changesSaved: response.changes_saved
				};
			} catch (error: any) {
				console.error('Failed to save cell changes:', error);

				// Rollback to original state
				update(s => ({ ...s, displayedMatrixData: originalMatrixData }));

				// Notify user of failure
				addToast('error', 'Failed to save changes. Please try again.');

				return { success: false, changesSaved: 0 };
			}
		},

		// Toggle risk heatmap
		toggleRiskHeatmap() {
			update(state => ({ ...state, showRiskHeatmap: !state.showRiskHeatmap }));
		},

		// Initialize matrix with placeholder data (before LLM generates real data)
		initializeMatrix() {
			const placeholderDimensions: CellDimension[] = Array.from({ length: 5 }, (_, i) => ({
				name: `Dimension ${i + 1}`,
				value: 50
			}));

			const placeholderCell: CellData = {
				value: 50,
				dimensions: placeholderDimensions,
				confidence: 0.5,
				description: '',
				isLeveragePoint: false,
				isRiskPoint: false,
				riskLevel: 'low'
			};

			const displayedMatrixData: CellData[][] = Array.from({ length: 5 }, () =>
				Array.from({ length: 5 }, () => ({ ...placeholderCell, dimensions: placeholderDimensions.map(d => ({ ...d })) }))
			);

			update(state => ({
				...state,
				documents: [],
				activeDocumentId: null,
				displayedMatrixData,
				displayedRowHeaders: ['Row 1', 'Row 2', 'Row 3', 'Row 4', 'Row 5'],
				displayedColumnHeaders: ['Column 1', 'Column 2', 'Column 3', 'Column 4', 'Column 5'],
				displayedRowInsights: ['', '', '', '', ''],
				displayedColumnInsights: ['', '', '', '', ''],
				isGenerated: false
			}));
		},

		// Toggle auto refresh
		toggleAutoRefresh() {
			update(state => ({ ...state, autoRefresh: !state.autoRefresh }));
		},

		// Set auto refresh state directly
		setAutoRefresh(enabled: boolean) {
			update(state => ({ ...state, autoRefresh: enabled }));
		},

		// Reset matrix
		reset() {
			set(initialState);
		},

		// Cell value update (used by MatrixPanel)
		updateCellValue(row: number, col: number, value: number) {
			update(state => {
				const newMatrixData = state.displayedMatrixData.map((r, rIdx) =>
					r.map((cell, cIdx) => {
						if (rIdx === row && cIdx === col) {
							return { ...cell, value };
						}
						return cell;
					})
				);
				return { ...state, displayedMatrixData: newMatrixData };
			});
		}
	};
}

export const matrix = createMatrixStore();

// Derived stores
export const documents = derived(matrix, ($matrix) => $matrix.documents);
export const activeDocumentId = derived(matrix, ($matrix) => $matrix.activeDocumentId);
export const activeDocument = derived(matrix, ($matrix) =>
	$matrix.documents.find(d => d.id === $matrix.activeDocumentId) || null
);

export const matrixData = derived(matrix, ($matrix) => $matrix.displayedMatrixData);
export const rowHeaders = derived(matrix, ($matrix) => $matrix.displayedRowHeaders);
export const columnHeaders = derived(matrix, ($matrix) => $matrix.displayedColumnHeaders);
export const rowInsights = derived(matrix, ($matrix) => $matrix.displayedRowInsights);
export const columnInsights = derived(matrix, ($matrix) => $matrix.displayedColumnInsights);

export const isMatrixGenerated = derived(matrix, ($matrix) => $matrix.isGenerated);
export const isMatrixProcessing = derived(matrix, ($matrix) => $matrix.isProcessing);
export const showRiskHeatmap = derived(matrix, ($matrix) => $matrix.showRiskHeatmap);
export const autoRefresh = derived(matrix, ($matrix) => $matrix.autoRefresh);

// Plays derived stores
export const plays = derived(matrix, ($matrix) => $matrix.plays);
export const selectedPlayId = derived(matrix, ($matrix) => $matrix.selectedPlayId);
export const isLoadingPlays = derived(matrix, ($matrix) => $matrix.isLoadingPlays);

// Computed metrics (from currently displayed matrix)
export const coherence = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	const cells = $matrix.displayedMatrixData.flat();
	return Math.round(cells.reduce((sum, cell) => sum + cell.confidence, 0) / cells.length * 100);
});

export const population = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	const cells = $matrix.displayedMatrixData.flat();
	return Math.round(cells.filter((c) => c.value > 0).length / cells.length * 100);
});

export const avgScore = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	const cells = $matrix.displayedMatrixData.flat();
	return Math.round(cells.reduce((sum, cell) => sum + cell.value, 0) / cells.length);
});

export const powerSpots = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	return $matrix.displayedMatrixData.flat().filter((c) => c.isLeveragePoint).length;
});

