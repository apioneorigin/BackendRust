/**
 * Matrix store - manages multi-document transformation matrix state
 *
 * ARCHITECTURE:
 * - Each document has its own 10x10 matrix (rows, columns, cells)
 * - Documents are displayed as tabs in Control Popup and Matrix Panel
 * - User can select 5 rows + 5 columns per document for display
 * - Row/column labels and insight titles are generated by LLM during document creation
 * - Articulated insights are generated on-demand when user clicks an insight title
 * - Document population (cells, plays, etc.) triggered via "Design Your Reality" button
 */

import { writable, derived, get } from 'svelte/store';
import { api } from '$utils/api';
import { addToast } from './toast';

export interface CellDimension {
	name: string;
	value: number;  // 0 (Low), 50 (Medium), or 100 (High)
	explanation?: string;  // Max 10-word phrase explaining this dimension's state
}

export interface CellData {
	value: number;
	dimensions: CellDimension[];
	confidence: number;
	description: string;
	isLeveragePoint: boolean;
	riskLevel?: 'low' | 'medium' | 'high';
}

// Articulated Insight structure based on insight-articulation-final.pdf
// 3-component structure: THE TRUTH → YOUR TRUTH → THE MARK (160-250 words total)
export interface ArticulatedInsight {
	// Insight title (max 10 words) - displayed in popup header
	title: string;               // Max 10-word title phrase for this insight

	// THE TRUTH (80-120 words): Analogy from outside user's domain
	the_truth: string;           // Italicized analogy, present tense, sensory
	the_truth_law: string;       // Bold one-line universal law (15-25 words)

	// YOUR TRUTH (50-80 words): Recognition + future protection
	your_truth: string;          // "I see you" + "never miss again" trigger
	your_truth_revelation: string;  // Bold revelation - what's now visible

	// THE MARK (30-50 words): Install the insight as permanent pattern
	the_mark_name: string;       // Memorable name, 2-5 words (e.g., "The Permission Gap")
	the_mark_prediction: string; // Where they'll see this pattern
	the_mark_identity: string;   // Bold new capability/identity
}

// Play (transformation strategy)
export interface Play {
	id: string;
	name: string;
	description: string;
	fitScore: number;
	risk: 'low' | 'medium' | 'high';
	timeline: string;
	phases: number;
	steps: string[];
	leveragePointIds: string[];
	expectedImprovement: number;
	category: string;  // "quick_wins", "balanced", "deep_transform", "conservative", "aggressive"
}

export interface RowOption {
	id: string;
	label: string;
	insight_title?: string;
	articulated_insight?: ArticulatedInsight;
}

export interface ColumnOption {
	id: string;
	label: string;
	insight_title?: string;
	articulated_insight?: ArticulatedInsight;
}

// New: Document with its own matrix data
export interface Document {
	id: string;
	name: string;
	description?: string;  // ~20 word description (optional in on-demand architecture)
	matrix_data: {
		row_options: RowOption[];
		column_options: ColumnOption[];
		selected_rows: number[];
		selected_columns: number[];
		cells?: Record<string, {
			impact_score: number;
			relationship?: string;
			dimensions: {
				name: string;
				value: number;  // 0 (Low), 50 (Medium), or 100 (High)
				explanation?: string;  // Max 10-word phrase explaining this dimension's state
			}[];
		}>;
	};
}

interface MatrixState {
	// All documents (each with its own matrix)
	documents: Document[];
	activeDocumentId: string | null;

	// Displayed 5x5 matrix (derived from active document's selections)
	displayedMatrixData: CellData[][];
	displayedRowHeaders: string[];
	displayedColumnHeaders: string[];
	displayedRowInsights: string[];
	displayedColumnInsights: string[];

	// Generation state
	isGenerated: boolean;

	// Risk heatmap state
	showRiskHeatmap: boolean;

	// Plays state
	plays: Play[];
	selectedPlayId: string | null;
	isLoadingPlays: boolean;

	error: string | null;

	// Conversation ID for API calls
	conversationId: string | null;

	// Auto refresh - when enabled, matrix auto-updates on next query
	autoRefresh: boolean;
}

// Create placeholder 5x5 matrix for initial render
function createPlaceholderMatrix(): CellData[][] {
	const placeholderDimensions: CellDimension[] = Array.from({ length: 5 }, (_, i) => ({
		name: `Dimension ${i + 1}`,
		value: 50
	}));

	const placeholderCell: CellData = {
		value: 50,
		dimensions: placeholderDimensions,
		confidence: 0.5,
		description: '',
		isLeveragePoint: false,
		riskLevel: 'low'
	};

	return Array.from({ length: 5 }, () =>
		Array.from({ length: 5 }, () => ({ ...placeholderCell, dimensions: placeholderDimensions.map(d => ({ ...d })) }))
	);
}

const initialState: MatrixState = {
	documents: [],
	activeDocumentId: null,

	displayedMatrixData: createPlaceholderMatrix(),
	displayedRowHeaders: ['Row 1', 'Row 2', 'Row 3', 'Row 4', 'Row 5'],
	displayedColumnHeaders: ['Column 1', 'Column 2', 'Column 3', 'Column 4', 'Column 5'],
	displayedRowInsights: ['', '', '', '', ''],
	displayedColumnInsights: ['', '', '', '', ''],

	isGenerated: false,

	showRiskHeatmap: false,

	plays: [],
	selectedPlayId: null,
	isLoadingPlays: false,

	error: null,
	conversationId: null,
	autoRefresh: false
};

function createMatrixStore() {
	const { subscribe, set, update } = writable<MatrixState>(initialState);

	// Helper to build displayed 5x5 from a document's selected rows/columns
	function buildDisplayedMatrix(doc: Document): {
		matrixData: CellData[][];
		rowHeaders: string[];
		columnHeaders: string[];
		rowInsights: string[];
		columnInsights: string[];
	} | null {
		if (!doc.matrix_data) return null;

		const placeholderDimensions: CellDimension[] = Array.from({ length: 5 }, (_, i) => ({
			name: `Dimension ${i + 1}`,
			value: 50  // Medium
		}));

		const { row_options = [], column_options = [], selected_rows = [0,1,2,3,4], selected_columns = [0,1,2,3,4] } = doc.matrix_data;
		// Nullish coalescing required: Pydantic serializes Optional[dict]=None as JSON null,
		// but JS destructuring defaults only apply for undefined, not null
		const cells = doc.matrix_data.cells ?? {};

		const rowHeaders = selected_rows.map(i => row_options[i]?.label || `Row ${i + 1}`);
		const columnHeaders = selected_columns.map(i => column_options[i]?.label || `Column ${i + 1}`);
		const rowInsights = selected_rows.map(i => row_options[i]?.insight_title || row_options[i]?.articulated_insight?.title || '');
		const columnInsights = selected_columns.map(i => column_options[i]?.insight_title || column_options[i]?.articulated_insight?.title || '');

		const matrixData: CellData[][] = selected_rows.map(rowIdx =>
			selected_columns.map(colIdx => {
				const cellKey = `${rowIdx}-${colIdx}`;
				const cell = cells[cellKey];

				if (!cell) {
					return {
						value: 50,
						dimensions: placeholderDimensions.map(d => ({ ...d })),
						confidence: 0.5,
						description: '',
						isLeveragePoint: false,
						riskLevel: 'low' as const
					};
				}

				let riskLevel: 'low' | 'medium' | 'high' = 'low';
				if (cell.impact_score >= 80) riskLevel = 'high';
				else if (cell.impact_score >= 50) riskLevel = 'medium';

				const isLeveragePoint = cell.impact_score >= 75 &&
					cell.dimensions?.some(d => d.value >= 75);

				const dimensions: CellDimension[] = cell.dimensions?.map(d => ({
					name: d.name,
					value: d.value,
					explanation: d.explanation
				})) || placeholderDimensions;

				return {
					value: cell.impact_score,
					dimensions: dimensions.length === 5 ? dimensions : placeholderDimensions,
					confidence: cell.impact_score / 100,
					description: cell.relationship || '',
					isLeveragePoint,
					riskLevel
				};
			})
		);

		return { matrixData, rowHeaders, columnHeaders, rowInsights, columnInsights };
	}

	// Patch a single document into the store and rebuild display if it's the active doc
	function applyDocumentUpdate(doc: Document) {
		update(state => {
			const docIndex = state.documents.findIndex(d => d.id === doc.id);
			if (docIndex === -1) return state;

			const updatedDocs = [...state.documents];
			updatedDocs[docIndex] = doc;

			if (state.activeDocumentId === doc.id) {
				const displayed = buildDisplayedMatrix(doc);
				if (!displayed) return { ...state, documents: updatedDocs };
				return {
					...state,
					documents: updatedDocs,
					displayedMatrixData: displayed.matrixData,
					displayedRowHeaders: displayed.rowHeaders,
					displayedColumnHeaders: displayed.columnHeaders,
					displayedRowInsights: displayed.rowInsights,
					displayedColumnInsights: displayed.columnInsights,
					isGenerated: !!doc.matrix_data?.cells && Object.keys(doc.matrix_data.cells).length > 0
				};
			}

			return { ...state, documents: updatedDocs };
		});
	}

	return {
		subscribe,

		// Set conversation ID for API calls
		setConversationId(conversationId: string) {
			update(state => ({ ...state, conversationId }));
		},

		// Populate from structured data received from backend (documents array format)
		populateFromStructuredData(data: { documents?: Document[] }) {
			if (!data || !data.documents || data.documents.length === 0) return;

			const documents = data.documents;

			// Find first document with valid matrix_data for display
			const activeDoc = documents.find(d => d.matrix_data) || documents[0];
			const activeDocumentId = activeDoc.id;
			const displayed = buildDisplayedMatrix(activeDoc);

			if (!displayed) {
				// All documents are stubs (no matrix_data) — store them but don't update display
				update(state => ({
					...state,
					documents,
					activeDocumentId,
					isGenerated: false
				}));
				return;
			}

			update(state => ({
				...state,
				documents,
				activeDocumentId,
				displayedMatrixData: displayed.matrixData,
				displayedRowHeaders: displayed.rowHeaders,
				displayedColumnHeaders: displayed.columnHeaders,
				displayedRowInsights: displayed.rowInsights,
				displayedColumnInsights: displayed.columnInsights,
				isGenerated: !!activeDoc.matrix_data?.cells && Object.keys(activeDoc.matrix_data.cells).length > 0
			}));
		},

		// Switch active document tab
		setActiveDocument(documentId: string) {
			update(state => {
				const doc = state.documents.find(d => d.id === documentId);
				if (!doc) return state;

				const displayed = buildDisplayedMatrix(doc);
				if (!displayed) return { ...state, activeDocumentId: documentId, isGenerated: false };

				return {
					...state,
					activeDocumentId: documentId,
					displayedMatrixData: displayed.matrixData,
					displayedRowHeaders: displayed.rowHeaders,
					displayedColumnHeaders: displayed.columnHeaders,
					displayedRowInsights: displayed.rowInsights,
					displayedColumnInsights: displayed.columnInsights,
					isGenerated: !!doc.matrix_data?.cells && Object.keys(doc.matrix_data.cells).length > 0
				};
			});
		},

		// Update row/column selection for active document
		async updateDocumentSelection(selectedRows: number[], selectedColumns: number[]) {
			const state = get({ subscribe });
			const activeDoc = state.documents.find(d => d.id === state.activeDocumentId);
			if (!activeDoc?.matrix_data || !state.conversationId) return;

			// Save original selection for rollback
			const originalRows = [...activeDoc.matrix_data.selected_rows];
			const originalCols = [...activeDoc.matrix_data.selected_columns];

			// Optimistic update
			update(s => {
				const docIndex = s.documents.findIndex(d => d.id === s.activeDocumentId);
				if (docIndex === -1) return s;

				const updatedDocs = [...s.documents];
				updatedDocs[docIndex] = {
					...updatedDocs[docIndex],
					matrix_data: {
						...updatedDocs[docIndex].matrix_data,
						selected_rows: selectedRows,
						selected_columns: selectedColumns
					}
				};

				const displayed = buildDisplayedMatrix(updatedDocs[docIndex]);
				if (!displayed) return { ...s, documents: updatedDocs };

				return {
					...s,
					documents: updatedDocs,
					displayedMatrixData: displayed.matrixData,
					displayedRowHeaders: displayed.rowHeaders,
					displayedColumnHeaders: displayed.columnHeaders,
					displayedRowInsights: displayed.rowInsights,
					displayedColumnInsights: displayed.columnInsights
				};
			});

			// Persist to backend
			try {
				await api.patch(`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/selection`, {
					document_id: state.activeDocumentId,
					selected_rows: selectedRows,
					selected_columns: selectedColumns
				});
			} catch (error) {
				console.error('Failed to persist document selection:', error);

				// Rollback to original selection
				update(s => {
					const docIndex = s.documents.findIndex(d => d.id === s.activeDocumentId);
					if (docIndex === -1) return s;

					const updatedDocs = [...s.documents];
					updatedDocs[docIndex] = {
						...updatedDocs[docIndex],
						matrix_data: {
							...updatedDocs[docIndex].matrix_data,
							selected_rows: originalRows,
							selected_columns: originalCols
						}
					};

					const displayed = buildDisplayedMatrix(updatedDocs[docIndex]);
					if (!displayed) return { ...s, documents: updatedDocs };

					return {
						...s,
						documents: updatedDocs,
						displayedMatrixData: displayed.matrixData,
						displayedRowHeaders: displayed.rowHeaders,
						displayedColumnHeaders: displayed.columnHeaders,
						displayedRowInsights: displayed.rowInsights,
						displayedColumnInsights: displayed.columnInsights
					};
				});

				addToast('error', 'Failed to update selection. Reverted.');
			}
		},

		// Delete a document (only from CC popup, never from Matrix panel)
		async deleteDocument(docId: string) {
			const state = get({ subscribe });
			if (!state.conversationId) {
				console.error('No conversation ID set');
				return;
			}

			if (state.documents.length <= 1) {
				addToast('error', 'Cannot delete the last document');
				return;
			}

			try {
				await api.delete(`/api/matrix/${state.conversationId}/document/${docId}`);

				update(s => {
					const remaining = s.documents.filter(d => d.id !== docId);
					// If deleted doc was active, switch to first remaining
					const needSwitch = s.activeDocumentId === docId;
					const newActiveId = needSwitch ? remaining[0]?.id ?? null : s.activeDocumentId;
					const newActiveDoc = remaining.find(d => d.id === newActiveId);

					if (needSwitch && newActiveDoc) {
						const displayed = buildDisplayedMatrix(newActiveDoc);
						if (displayed) {
							return {
								...s,
								documents: remaining,
								activeDocumentId: newActiveId,
								displayedMatrixData: displayed.matrixData,
								displayedRowHeaders: displayed.rowHeaders,
								displayedColumnHeaders: displayed.columnHeaders,
								displayedRowInsights: displayed.rowInsights,
								displayedColumnInsights: displayed.columnInsights,
								isGenerated: !!newActiveDoc.matrix_data?.cells && Object.keys(newActiveDoc.matrix_data.cells).length > 0
							};
						}
						return { ...s, documents: remaining, activeDocumentId: newActiveId, isGenerated: false };
					}

					return { ...s, documents: remaining };
				});

				addToast('info', 'Document deleted');
			} catch (error: any) {
				console.error('Failed to delete document:', error);
				addToast('error', 'Failed to delete document');
			}
		},

		// Populate a document with full cell data via "Design Your Reality"
		async populateDocument(docId: string, model: string = 'claude-opus-4-5-20251101') {
			const state = get({ subscribe });
			if (!state.conversationId) {
				console.error('No conversation ID set');
				return;
			}

			try {
				// Backend returns the updated document directly — no follow-up GET needed
				const doc = await api.post<Document>(
					`/api/matrix/${state.conversationId}/document/${docId}/design-reality`,
					{ model }
				);

				if (doc?.matrix_data) {
					applyDocumentUpdate(doc);
				}

				return doc;
			} catch (error: any) {
				console.error('Failed to populate document:', error);
				throw error;
			}
		},

		// Generate all missing insights for the active document
		async generateInsights(insightIndex: number, model: string): Promise<Document | null> {
			const state = get({ subscribe });
			if (!state.conversationId || !state.activeDocumentId) return null;

			// Backend returns the updated document directly — no follow-up GET needed
			const doc = await api.post<Document>(
				`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/generate-insights`,
				{ model, insight_index: insightIndex }
			);

			if (doc?.matrix_data) {
				applyDocumentUpdate(doc);
				return doc;
			}
			return null;
		},

		// Fetch plays for active document (plays are generated during document population)
		async fetchPlays() {
			const state = get({ subscribe });
			if (!state.conversationId || !state.activeDocumentId) {
				console.error('No conversation or document ID set');
				return [];
			}

			update(s => ({ ...s, isLoadingPlays: true, error: null }));

			try {
				const response = await api.get<{ plays: Play[]; selectedPlayId: string | null }>(
					`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/plays`
				);
				const plays = response.plays || [];
				const selectedPlayId = response.selectedPlayId || null;

				update(s => ({
					...s,
					plays,
					selectedPlayId,
					isLoadingPlays: false
				}));

				return plays;
			} catch (error: any) {
				update(s => ({
					...s,
					plays: [],
					isLoadingPlays: false,
					error: error.message || 'Failed to fetch plays'
				}));
				return [];
			}
		},

		// Select a play
		async selectPlay(playId: string | null) {
			const state = get({ subscribe });
			if (!state.conversationId || !state.activeDocumentId) {
				console.error('No conversation or document ID set');
				return;
			}

			try {
				await api.put(
					`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/plays/select`,
					{ play_id: playId }
				);

				update(s => ({ ...s, selectedPlayId: playId }));
			} catch (error: any) {
				console.error('Failed to select play:', error);
			}
		},

		// Update cell dimension value (local state only)
		updateCellDimension(rowIdx: number, colIdx: number, dimIdx: number, value: number) {
			update(state => {
				const newMatrixData = state.displayedMatrixData.map((row, r) =>
					row.map((cell, c) => {
						if (r === rowIdx && c === colIdx) {
							const newDimensions = cell.dimensions.map((dim, d) =>
								d === dimIdx ? { ...dim, value } : dim
							);
							return { ...cell, dimensions: newDimensions };
						}
						return cell;
					})
				);
				return { ...state, displayedMatrixData: newMatrixData };
			});
		},

		// Save cell dimension changes to backend
		async saveCellChanges(changes: Array<{ row: number; col: number; dimIdx: number; value: number }>) {
			const state = get({ subscribe });
			if (!state.conversationId || !state.activeDocumentId) {
				console.error('No conversation or document ID set');
				return { success: false, changesSaved: 0 };
			}

			if (changes.length === 0) {
				return { success: true, changesSaved: 0 };
			}

			// Save original state for rollback
			const originalMatrixData = state.displayedMatrixData.map(row =>
				row.map(cell => ({
					...cell,
					dimensions: cell.dimensions.map(dim => ({ ...dim }))
				}))
			);

			try {
				// Apply changes to local state first (optimistic update)
				update(s => {
					const newMatrixData = s.displayedMatrixData.map((row, r) =>
						row.map((cell, c) => {
							const cellChanges = changes.filter(ch => ch.row === r && ch.col === c);
							if (cellChanges.length === 0) return cell;

							const newDimensions = cell.dimensions.map((dim, d) => {
								const dimChange = cellChanges.find(ch => ch.dimIdx === d);
								return dimChange ? { ...dim, value: dimChange.value } : dim;
							});
							return { ...cell, dimensions: newDimensions };
						})
					);
					return { ...s, displayedMatrixData: newMatrixData };
				});

				// Persist to backend
				const response = await api.patch<{ success: boolean; changes_saved: number }>(
					`/api/matrix/${state.conversationId}/document/${state.activeDocumentId}/cells`,
					{
						changes: changes.map(ch => ({
							row_idx: ch.row,
							col_idx: ch.col,
							dim_idx: ch.dimIdx,
							value: ch.value
						}))
					}
				);

				return {
					success: response.success,
					changesSaved: response.changes_saved
				};
			} catch (error: any) {
				console.error('Failed to save cell changes:', error);

				// Rollback to original state
				update(s => ({ ...s, displayedMatrixData: originalMatrixData }));

				// Notify user of failure
				addToast('error', 'Failed to save changes. Please try again.');

				return { success: false, changesSaved: 0 };
			}
		},

		// Toggle risk heatmap
		toggleRiskHeatmap() {
			update(state => ({ ...state, showRiskHeatmap: !state.showRiskHeatmap }));
		},

		// Initialize matrix with placeholder data (before LLM generates real data)
		initializeMatrix() {
			const placeholderDimensions: CellDimension[] = Array.from({ length: 5 }, (_, i) => ({
				name: `Dimension ${i + 1}`,
				value: 50
			}));

			const placeholderCell: CellData = {
				value: 50,
				dimensions: placeholderDimensions,
				confidence: 0.5,
				description: '',
				isLeveragePoint: false,
				riskLevel: 'low'
			};

			const displayedMatrixData: CellData[][] = Array.from({ length: 5 }, () =>
				Array.from({ length: 5 }, () => ({ ...placeholderCell, dimensions: placeholderDimensions.map(d => ({ ...d })) }))
			);

			update(state => ({
				...state,
				displayedMatrixData,
				displayedRowHeaders: ['Row 1', 'Row 2', 'Row 3', 'Row 4', 'Row 5'],
				displayedColumnHeaders: ['Column 1', 'Column 2', 'Column 3', 'Column 4', 'Column 5'],
				displayedRowInsights: ['', '', '', '', ''],
				displayedColumnInsights: ['', '', '', '', ''],
				isGenerated: false
			}));
		},

		// Toggle auto refresh
		toggleAutoRefresh() {
			update(state => ({ ...state, autoRefresh: !state.autoRefresh }));
		},

		// Set auto refresh state directly
		setAutoRefresh(enabled: boolean) {
			update(state => ({ ...state, autoRefresh: enabled }));
		},

		// Reset matrix
		reset() {
			set(initialState);
		},

		// Cell value update (used by MatrixPanel)
		updateCellValue(row: number, col: number, value: number) {
			update(state => {
				const newMatrixData = state.displayedMatrixData.map((r, rIdx) =>
					r.map((cell, cIdx) => {
						if (rIdx === row && cIdx === col) {
							return { ...cell, value };
						}
						return cell;
					})
				);
				return { ...state, displayedMatrixData: newMatrixData };
			});
		}
	};
}

export const matrix = createMatrixStore();

// Derived stores
export const documents = derived(matrix, ($matrix) => $matrix.documents);
export const activeDocumentId = derived(matrix, ($matrix) => $matrix.activeDocumentId);
export const activeDocument = derived(matrix, ($matrix) =>
	$matrix.documents.find(d => d.id === $matrix.activeDocumentId) || null
);

export const matrixData = derived(matrix, ($matrix) => $matrix.displayedMatrixData);
export const rowHeaders = derived(matrix, ($matrix) => $matrix.displayedRowHeaders);
export const columnHeaders = derived(matrix, ($matrix) => $matrix.displayedColumnHeaders);
export const rowInsights = derived(matrix, ($matrix) => $matrix.displayedRowInsights);
export const columnInsights = derived(matrix, ($matrix) => $matrix.displayedColumnInsights);

export const isMatrixGenerated = derived(matrix, ($matrix) => $matrix.isGenerated);
export const showRiskHeatmap = derived(matrix, ($matrix) => $matrix.showRiskHeatmap);
export const autoRefresh = derived(matrix, ($matrix) => $matrix.autoRefresh);

// Plays derived stores
export const plays = derived(matrix, ($matrix) => $matrix.plays);
export const selectedPlayId = derived(matrix, ($matrix) => $matrix.selectedPlayId);
export const isLoadingPlays = derived(matrix, ($matrix) => $matrix.isLoadingPlays);

// Computed metrics (from currently displayed matrix)
export const coherence = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	const cells = $matrix.displayedMatrixData.flat();
	return Math.round(cells.reduce((sum, cell) => sum + cell.confidence, 0) / cells.length * 100);
});

export const population = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	const cells = $matrix.displayedMatrixData.flat();
	return Math.round(cells.filter((c) => c.value > 0).length / cells.length * 100);
});

export const avgScore = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	const cells = $matrix.displayedMatrixData.flat();
	return Math.round(cells.reduce((sum, cell) => sum + cell.value, 0) / cells.length);
});

export const powerSpots = derived(matrix, ($matrix) => {
	if ($matrix.displayedMatrixData.length === 0) return 0;
	return $matrix.displayedMatrixData.flat().filter((c) => c.isLeveragePoint).length;
});

